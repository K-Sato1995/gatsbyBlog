---
title: "情報の基礎理論"
slug: 情報の基礎理論
date: 2019-03-12
language: japanese
tags:
  - ComputerScience
published: true
description: " コンピュータ内でのデータの表され方から、データ構造(Data Structure), アルゴリズム(Algorithm)の基礎までまとめました。"
---
# 情報の表現

## 情報の単位

- `ビット(bit)`:コンピュータの扱う最小の単位。2 進数の１桁に相当する(0/1)。
- `バイト(byte)`:ビット 8 個を集めたもの。2 進数の 8 桁に相当する。(`256 通り`の情報量を表せる。)

## 情報量を表す接頭語

以下の表からわかるように単位が１つ上がるごとに`1000`(`1024`)倍していく事で各単位の情報量が求められる。
(`1024倍`)なのは 2 進数を基準にしているため。(`2**10` = `1024` )

| 接頭語    | 意味               |
| --------- | ------------------ |
| `k(キロ)` | 1KB = 1000(1024)B  |
| `M(メガ)` | 1MB = 1000(1024)KB |
| `G(ギガ)` | 1GB = 1000(1024)MB |
| `T(テラ)` | 1TB = 1000(1024)GB |

[バイトの単位（KB、MB、GB、TB）の意味と換算 - 具体例で学ぶ数学](https://mathwords.net/kbmb)

## ビット数と表現できる情報量

1 ビットで表現できる情報量は「0」と「1」の`2通り(=2**1)`。  
2 ビットでは「00」「01」「10」「11」の`4通り(2**2)`
つまり、`n`ビットで表現できる情報量は`2**n`の式で求める事ができる。

## 指数計算

基本的な指数計算の公式。

```ruby
# m, nが整数の場合。
# (1)
(a**m) * (a**n) = a**(m + n)
→ (2**3) * (2**2) = 2**5

# (2)
a**m / a**n =  a**(m - n)
→ (2**3) / (2**2) = 2**1

# (3)
(a**m)**n = a**m*n
→ (2**3)**2 = 2**(3*2)
```

## 文字コード

コンピュータでは文字の 1 つ 1 つに特定の 2 進数が割り当てられていて、文字という情報をコード化している。

| 名称              | 意味                                                                                 |
| ----------------- | ------------------------------------------------------------------------------------ |
| `ASCIIコード`     | 英数字と特殊文字のみ。漢字・かなに関する規定はない。                                 |
| `シフトJISコード` | ASCII コードと漢字・かなが混在可能。                                                 |
| `EUC`             | UNIX や Linux で用いられる文字コード。漢字・かなが使用可能。                         |
| `UNICODE`         | 世界の文字の多くを１つの体系で表現するコード。UTG-8 は UNICODE の符号化方式の 1 つ。 |

# 基数変換

- `基数`:各桁の重み付けの基本となる数。(10 進数の基数は 10、2 進数の基数は 2、8 進数の基数は 8...)
- `基数変換`:ある進数で表していた数を別の進数に直す事。(2 進数 →10 進数、8 進数 →10 進数)

```ruby
# 基数の重み
小数点を基準に左へ N**0, N**1, N**2...
小数点を基準に右へ N**-1, N**-2...
```

**例)2 進数の重みの遷移**

| 2\*\*3 | 2\*\*2 | 2\*\*1 | 2\*\*0 | .   | 2\*\*-1 | 2\*\*-2 | 2\*\*-3 | 2\*\*-4 |
| ------ | ------ | ------ | ------ | --- | ------- | ------- | ------- | ------- |


**10 進数、2 進数、8 進数、16 進数の関係は以下の表のようになる。**

| 10 進数 | 2 進数 | 8 進数 | 16 進数 |
| ------- | ------ | ------ | ------- |
| 0       | 0      | 0      | 0       |
| 1       | 1      | 1      | 1       |
| 2       | 10     | 2      | 2       |
| 3       | 11     | 3      | 3       |
| 4       | 100    | 4      | 4       |
| 5       | 101    | 5      | 5       |
| 6       | 110    | 6      | 6       |
| 7       | 111    | 7      | 8       |
| 8       | 1000   | 10     | 8       |
| 9       | 1001   | 11     | 9       |
| 10      | 1010   | 12     | A       |
| 11      | 1011   | 13     | B       |
| 12      | 1100   | 14     | C       |
| 13      | 1101   | 15     | D       |
| 14      | 1110   | 16     | E       |
| 15      | 1111   | 17     | F       |
| 16      | 10000  | 20     | 10      |

## N 進数から 10 進数の基数変換
各桁に N 進数の重みを掛けて足す。

例)2 進数から 10 進数

```
101.101
を上記の基数の重みに従って変更すると、
(1*4)+(0*4)+(1*2).(1*1/2)+(0*1/4)+(1*1/8)
これを足し合わせると10進数5.625が求められる。
```

## 10 進数から N 進数の基数変換

**(整数)** 10 進数の整数部を 2 進数で表すには、以下のように 2 で割って、あまりを下から並べる。

![image](https://user-images.githubusercontent.com/32632542/53702306-e01bda80-3e48-11e9-8d02-4a4d6d5d8624.png)

**(少数)** 10 進数の少数部を 2 進数で表すには、以下のように各少数に 2 を掛けて、整数部を並べる。

![image](https://user-images.githubusercontent.com/32632542/53702401-c62ec780-3e49-11e9-8761-be4d7b0174f7.png)

## 10 進数 →N 進数変換ルール

```
(整数部): Nで割って下から余りを並べる。
(少数部): Nを掛けて順に整数を並べる。
```

## 2 進数から 8 進数、16 進数への変換

- 2 進数から 8 進数への変換の場合は以下のように、小数点を基準に 3 桁ずつ区切ってそれぞれを 8 進数で表す。(3 桁にならない場合は 0 を補う。)
- 2 進数から 16 進数への変換の場合は以下のように、小数点を基準に 4 桁ずつ区切ってそれぞれを 16 進数で表す。(4 桁にならない場合は 0 を補う。)

![image](https://user-images.githubusercontent.com/32632542/54238814-cff8af00-455c-11e9-9c25-536b91326388.png)

# 補数表現と固定少数点表示

- `補数`:「ある数」を「決められた数」にするために「補う数」の事。(例:10 に対する３の補数は７)  
  補数を用いる事でマイナス記号をしようせず、負の数の表現ができる。

```ruby
# 補数で負の数を表現する例

以下のような計算をしたい場合、

15 - 3 = 12

15は2桁の数字なので100がベースとなり、3の100に対する補数は97なので、97を15に足す。

15 + 97 = 112

ここで、桁上がりした左端の1を取り除くと、答えである12が得られる。

上の式を分解すると以下のようになっている。

15 + (100 - 2) = (100 + 12)

それぞれ100を取り除くと元の式と同じになっている事がわかる。

つまり上記では負の記号を用いず-3を表している。
```

## 2 進数の補数
2 進数には以下の２つの補数がある。

- `1の補数`:足しても桁上がりしない数のうち最大の数。
- `2の補数`:足す事で桁上がりさせる数。

### 1 の補数の計算
`1の補数`はある 2 進数のビットを反転する事で求められる。

```ruby
# 1の補数の計算例

0101の1の補数は1010となる。
```

## 2の補数の計算
ビットを反転する事で求めた`1の補数`に 1 を加える事で求められる。

```ruby
# 2の補数の計算例

0101の1の補数は1010となる。

↓ (これに1を加える。)

1011が0101の2の補数となる。
```

# 固定小数点
コンピュータ内部の数値表現方法には`固定少数点表示`と`有働小数点表示`が存在する。

- `固定小数点表示`:小数点があらかじめ決められた位置に固定されている表現方式。

# 浮動小数点表示

- `浮動小数点表示`:実数を `M ×B**e` の形で表したもの。(例えば、十進法で 12345.67 を `1.234567×10**4` と表せる。)

ここで M の部分を`仮数部`,B の部分を`基数`、そして e の部分は`指数`と呼ばれます。  
浮動小数点表示では`指数`を使用する事で、大きな数や小さな数を少ないビット数で表現できる。

![image](https://user-images.githubusercontent.com/32632542/53765083-60f2d900-3f12-11e9-9b15-93dff393866f.png)

以下の様にして指数を用いて同じ数を別の方法で表現する。

```ruby
123 * 10**0
12.3 * 10**1
1.23 * 10**2
0.123 * 10**3

上記の様に小数点の位置がふわふわと浮いて移動している様に見える事から、浮動小数点表示と呼ばれる。
```

[【基本情報】浮動小数点表示【おぼえがき】 : 日々、徒然プログラミング。](http://chocoffee.cafeblog.jp/archives/8742312.html)

- `正規化`:仮数部と指数部を調整して一意に決める事。

# 誤差

- `誤差`:コンピュータ内部では数値を指定されたビット数で表しているので、それによって発生する真の値との間に差のこと。
- `桁あふれ誤差`:演算結果がコンピュータの表現できる範囲を越える事によって発生する誤差。

※表現できる最大値を越える事を`オーバーフロー`、最小値を越える事を`アンダーフロー`と呼びます。

- `丸め誤差`:指定された有効桁数で演算結果を表すために、切り捨て、切り上げ、四捨五入などを行うために発生する誤差。
- `桁落ち`:絶対値のほぼ等しい 2 つ数の差を求めた時、有効桁数が減るために発生する誤差。
- `情報落ち`:絶対値の非常に大きな数と小さな数の加算・減算を行なった時、小さい数が演算結果に反映されないために発生する誤差。
- `打ち切り誤差`:浮動小数点数の計算処理の打ち切りを、指定した規則で行うことによって発生する誤差。

# シフト演算

- `シフト演算`:左右に桁をずらす事で簡単に乗算や除算を行う操作の事。
- `論理シフト`:符号を考慮せず、左シフト・右シフト共にあふれたビットは捨てられ、空いたビットには 0 が入る。

![image](https://user-images.githubusercontent.com/32632542/53915103-9fb79900-40a2-11e9-8684-d68e377fb3ce.png)

- `算術シフト`:符号を考慮してシフトを行う。

![image](https://user-images.githubusercontent.com/32632542/53915246-ec9b6f80-40a2-11e9-8e05-1d066f5d7ae9.png)

- `算術左シフト`:符号ビットはそのままの位置にとどまる。あふれたビットは捨てられ、空いたビットには 0 が入る。
- `算術右シフト`:符号ビットはそのまま、あふれたビットは捨てられ、空いたビットには符号と同じビットが入る。

![image](https://user-images.githubusercontent.com/32632542/54238896-09311f00-455d-11e9-9a12-e95234c799a7.png)

# 計測・制御

## アナログとデジタル

- `アナログデータ`:数や量を連続的な物理量（長さ・角度・電流など）で表現する方式。
- `デジタルデータ`:コンピューターで処理可能な 0 と 1 の 2 進法で書き換えられた映像・音・数値・テキストなどのデータ。
- `A/D変換`:アナログデータをデジタルデータに変換する事。

## PCM 方式(パルス符号変調方式)

- `PCM(パルス符号変調方式)`:A/D 変更を行う代表的な方法。

`PCM`では`標本化`→`量子化`→`符号化`の順に変換を行う。

![image](https://user-images.githubusercontent.com/32632542/53916253-063db680-40a5-11e9-9938-a31f47d227b0.png)

- `標本化(サンプリング)`:時間的に連続したアナログ信号の波形を、一定の時間感覚で測定する。
- `量子化`:測定した信号をあらかじめけめられた一定の間隔(2,**8,2**16..等)に区切り数値化する。
- `符号化`:量子化された値を 2 進数のデジタル符号に変換する。

## 制御技術
エアコンでで温度の上げ下げをする際に、センサが計測した室温をアナログ電圧として出力し、コンピュータがデジタルデータに変換して設定した値と比較している。
これが`コンピュータ制御`の例。

コンピュータ制御には主に以下の要素を用いる。

- `A/Dコンバータ`:アナログ電気信号を、コンピュータが処理可能なデジタル信号に変える。
- `センサ`:物理量を検出して、電気信号に変える。
- `アクチュエータ`:コンピュータが出力した電気信号を回転運動・直線運動に変える。(シリンダ・モータなど。)

# オートマトン

- `オートマトン`:、計算機の構造や動作を抽象化したモデルの一つで、内部に固有の状態と、状態を変化させる規則の集合を持ち、外部からの入力に応じて状態を変化させるもの。

# 論理演算と論理回路

- `論理演算`:1 と 0 という２つの値を扱う演算。(`論理和(OR)`, `論理積(AND)`, `否定(NOT)`が基本。)
- `論理回路`:論理演算を実際に行う回路。(`MIL記号`で図式化したり、`論理表`で表されたりする。)

## 基本回路

- `論理和回路(OR回路)`:入力(A,B)の少なくとも一方が 1 であれば、出力(A+B)は 1 になる回路。

![image](https://user-images.githubusercontent.com/32632542/53990013-a3aeee00-416a-11e9-806a-f90a845b947a.png)

```
少なくとも一方が1ならば1
```

- `論理積回路(AND回路)`:入力(A,B)の両方が 1 であれば出力(A・B)は 1 になる回路。

```
AとB両方が1ならば1
```

![image](https://user-images.githubusercontent.com/32632542/53990244-3059ac00-416b-11e9-9b46-f24f8fc46d3d.png)

- `否定回路(NOT回路)`:入力(A)が 0 であれば出力(A)は 1、入力(A)が 0 であれば出力(A)は 0 になる回路。

```
0ならば1、1ならば0
```

![image](https://user-images.githubusercontent.com/32632542/53990453-ac53f400-416b-11e9-998e-d4eebb9d7ff9.png)

## 基本回路組み合わせ

- `排他的論理回路(EOR回路/XOR回路)`:入力(A,B)が異なれば出力は 1 になる回路。

```
AとBで異なれば1
```

![image](https://user-images.githubusercontent.com/32632542/53990832-8549f200-416c-11e9-8e0a-5ed3a930c34d.png)

- `否定論理和回路(NOR)回路`:論理和と否定の組み合わせ。

```
AとBが両方0なら1
(論理和の否定)
```

![image](https://user-images.githubusercontent.com/32632542/53991146-54b68800-416d-11e9-9fb7-71e9229e001f.png)

- `否定論理積`:論理積と否定の組み合わせ。

```
AとB両方が1ならば0、それ以外は1
(論理積の否定)
```

![image](https://user-images.githubusercontent.com/32632542/53991344-bbd43c80-416d-11e9-9b0e-fe257aa29ed0.png)

# 半加算器・全加算器

基本的な回路の組み合わせで加算を実現する回路を作る事が出来ます。

- `加算器`:2 進数の加算を行う回路の事。

`加算器`には以下の 2 種類が存在する。

```
(1)半加算器:
- 下位桁からの桁上がりを考慮しない。
- 上位桁への桁上がりを考慮する。
- 論理和(OR)と排他的論理和(EOR回路/XOR回路)の組み合わせで実現する。

(2)全加算器:
- 下位桁からの桁上がり・上位桁への桁上がりの両方を考慮する。
- 半加算器と論理和(OR)の組み合わせで実現する。
```

# アルゴリズム

- `アルゴリズム`:何らかの問題を有限の時間で解くための手順の事。

## フローチャートとアルゴリズム

アルゴリズムを表現する手法には`フローチャート(流れ図)`と`疑似言語`が存在する。

## フローチャート

以下の記号を用いてフローチャートを作成しアルゴリズムを記述する事ができる。

![image](https://user-images.githubusercontent.com/32632542/54091507-254d8880-43c4-11e9-8d34-f56603c70a8f.png)

## 疑似言語

`疑似言語`を用いる事で実際のプログラミング言語で記述する場合と近いイメージで記述できる。

![image](https://user-images.githubusercontent.com/32632542/54091558-ba508180-43c4-11e9-9de5-259401573414.png)

# 配列

- `データ構造`:データの集まりをコンピュータプログラムで処理する際に扱いやすいように、一定の形式で格納したもの。
- `配列`:同じデータ型の要素が集まったデータ構造。
- `インデックス(添字)`:要素が配列の中で何番目かを表す数字。

![image](https://user-images.githubusercontent.com/32632542/54239035-64631180-455d-11e9-9148-f3c7ea930383.png)

`2次元配列`の場合は行と列を区別する 2 つのインデックスが必要となる。

![image](https://user-images.githubusercontent.com/32632542/54091641-ba9d4c80-43c5-11e9-81d4-3d5094e0d2f7.png)

# リスト構造

- `リスト`:データ部とポインタ部で構成され、ポインタを辿ることによってデータを取り出す事ができるデータ構造。

## リスト構造の種類

リスト構造にはポインタの指す方向によって以下の種類に分類される。

- `単方向リスト`: 次のデータへのポインタを 1 つだけ持っているリスト構造。

![image](https://user-images.githubusercontent.com/32632542/54091755-0dc3cf00-43c7-11e9-991d-cd4c308a53e9.png)

- `双方向リスト`: 次のデータへのポインタの他に、前へのデータのポインタを持っているリスト構造。

![image](https://user-images.githubusercontent.com/32632542/54091763-2b913400-43c7-11e9-8930-b3ce9ebdfe1e.png)

- `環状リスト`: ポインタによって、データが環状に連結されているリスト構造。

![image](https://user-images.githubusercontent.com/32632542/54091742-ec62e300-43c6-11e9-8050-8504f14fd234.png)

# キューとスタック

## キュー(Queue)

- `キュー(Queue)`:格納した順序でデータを取り出す事ができるデータ構造。

この様な特徴を`FIFO(First In First Out)`と呼び、最初に格納したデータは最初に取り出す事が出来る。

- `エンキュー(enqueue)`:データをキューに格納する事。
- `デキュー(dequeue)`:キューからデータを取り出す事。

## スタック(Stack)

- `スタック(Stack)`:格納した順序とは逆の順番でデータを取り出す事ができるデータ構造。

この様な特徴を`LIFO(Last In First Out)`と呼び、最後に格納したデータを最初に取り出す事が出来る。

- `プッシュ(push)`:データをスタックに格納する事。
- `ポップ(pop)`:スタックからデータを取り出す事。

![image](https://user-images.githubusercontent.com/32632542/54091793-8a56ad80-43c7-11e9-8719-b50d124f5479.png)

# 木構造(ツリー構造)

- `木構造(ツリー構造)`:階層の上位から下位に節点を辿る事でデータを取り出す事が出来るデータ構造。

下記の図からもわかる様に、`○`の部分を`節(ノード)`、節と節を繋いだ`-`を`枝(ブランチ)`、最上位の節を`根(ルート)`、最下位の節を`葉(リーフ)`と呼ぶ。

![image](https://user-images.githubusercontent.com/32632542/54091943-99d6f600-43c9-11e9-94bf-1fdc15cf0837.png)

また、木構造には親子関係があり、上位の節を`親`、下位の節を`子`といい、節にぶら下がっている部分を`部分木`、中でも左側にぶら下がっているものを`左部分木`、右のものを`右部分木`と呼ぶ。

![image](https://user-images.githubusercontent.com/32632542/54091997-4618dc80-43ca-11e9-9cbb-e6753df1232a.png)

## 2 分木(binary tree)の種

- `2分木(binary tree)`:全ての枝の分岐が 2 つ以下である木構造。

以下の様な種類が存在する。

`完全２分木(complete binary tree)`:根から葉までの深さが全て等しい２分木。(深さが 1 だけ深い葉があり、木全体の左から詰められているものも完全 2 分木とされる。)

![image](https://user-images.githubusercontent.com/32632542/54158852-d6b8f080-448e-11e9-8890-83595c4c53cf.png)

`2分探索木(binary search tree)`:各節において`「左の子＜右の子」`という関係を持った 2 分木。

![image](https://user-images.githubusercontent.com/32632542/54158997-38795a80-448f-11e9-96e9-591bdb315ae3.png)

`ヒープ木`:各節において`「親＞子」`または`「子＞親」`という関係を持った完全 2 分木。(データを整列するのに使用される。)

「親＞子」の場合は根の値が最大値となり、「子＞親」の場合は根が最小値となる。

![image](https://user-images.githubusercontent.com/32632542/54159464-60b58900-4490-11e9-9d88-dcbfd7b79dba.png)

`逆ポーランド記法(Reverse Polish Notation, RPN)`:2 分木を使用して算術式を表記する方法の 1 つ。

![image](https://user-images.githubusercontent.com/32632542/54159697-f18c6480-4490-11e9-8abc-faebd0052abc.png)

[逆ポーランド記法と木構造の絵 - Qiita](https://qiita.com/yumura_s/items/ddb0d143fb0e9a082891)

# データの整列(ソート)

- `整列(ソート)`:ある規則に従ってデータを昇順または降順で並べ換える事。
- `昇順`:データの値の大きなものから小さなものに並び替える事。
- `降順`:データの値の小さなものから大きなものに並び替えること。

## 基本交換法(Bubble sort)

- `基本交換法(バブルソート)`:隣り合う要素を比較し、逆順であれば交換して、整列を行う方法。

![image](https://user-images.githubusercontent.com/32632542/54160021-d110da00-4491-11e9-98e8-8cb2c0843869.png)

## 基本選択法(Selection sort)

- `基本選択法(selection sort)`:対象の集合から最も小さい要素を順次取り出して、端においていく整列方法。

![image](https://user-images.githubusercontent.com/32632542/54160315-8ba0dc80-4492-11e9-8b3b-7794b180b964.png)

## 基本挿入法(Insertion sort)

- `基本選択法(Insertion sort)`:対象集合から要素を順次取り出し、それまでにソートを行なった要素の集合に順序関係を保つ様挿入して整列を行う方法。

![image](https://user-images.githubusercontent.com/32632542/54160507-141f7d00-4493-11e9-8636-854592a5a7d7.png)

## 計算量(オーダ)

- `O(オーダ)`:プログラムの計算量を表すのに用いられる。

基本交換法(Bubble sort)・選択ソート(Selection sort)・挿入ソート(Insertion sort)の計算量は`O(n**2)`.

## その他のソート

## シェルソート(改良挿入法)

- [シェルソート - Algoful](http://algoful.com/Archive/Algorithm/ShellSort)

## クイックソート

- [クイックソート - Algoful](http://algoful.com/Archive/Algorithm/QuickSort)

## ヒープソート

- [ヒープソート - Algoful](http://algoful.com/Archive/Algorithm/HeapSort)

# データの探索(Search)

- `データの探索(search)`:配列などを使用して目的のデータを探し出すことをデータの探索と言います。

## 線形探索法(Linear search)

- `線形探索法(Linear search)`:配列の先頭から順番に目的のデータを調べていく方法。

![image](https://user-images.githubusercontent.com/32632542/54237048-6e364600-4558-11e9-870e-ffd3241da5c8.png)

- `番兵法`:探索したい目的のデータを配列の最後尾に追加する方法。(線形探索法で追加した要素まで値が発見できない場合、値は存在しなかったことになる。)

```ruby
# 線形探索法の計算量

最大探索回数: N回
平均探索回数: (N+1)/2

計算量: O(N)
```

## 2 分探索法

- `2分探索法(Binary search)`:リストや配列に入ったソート済のデータに対して、中央値を基準にどんどん探索範囲を絞って効率的に探索を行うアルゴリズム。

- [二分探索法（バイナリサーチ） - Algoful](http://algoful.com/Archive/Algorithm/BinarySearch)

## ハッシュ探索法

- `ハッシュ探索法(Hash search)`:キーの間数値によって格納先のアドレスを算出し、直接探索する方法。(`O(1)` という圧倒的に小さい計算量で探索を行える)
- [ハッシュ探索](https://programming-place.net/ppp/contents/algorithm/search/006.html)
